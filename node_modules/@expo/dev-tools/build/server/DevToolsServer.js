'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startAsync = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

let startAsync = exports.startAsync = (() => {
  var _ref = (0, _asyncToGenerator3.default)(function* (projectDir) {
    const port = yield (0, _freeportAsync2.default)(19002);
    const server = (0, _express2.default)();

    server.use('/_next', _express2.default.static(_path2.default.join(__dirname, '../client/_next'), {
      // All paths in the _next folder include hashes, so they can be cached more aggressively.
      immutable: true,
      maxAge: '1y',
      setHeaders
    }));
    server.use(_express2.default.static(_path2.default.join(__dirname, '../client'), { setHeaders }));

    const httpServer = _http2.default.createServer(server);
    yield new _promise2.default(function (resolve, reject) {
      httpServer.once('error', reject);
      httpServer.once('listening', resolve);
      httpServer.listen(port);
    });
    startGraphQLServer(projectDir, httpServer);
    yield _xdl.ProjectSettings.setPackagerInfoAsync(projectDir, { devToolsPort: port });
    return `http://localhost:${port}`;
  });

  return function startAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

exports.startGraphQLServer = startGraphQLServer;

var _xdl = require('xdl');

var _subscriptionsTransportWs = require('subscriptions-transport-ws');

var _graphql = require('graphql');

var graphql = _interopRequireWildcard(_graphql);

var _express = require('express');

var _express2 = _interopRequireDefault(_express);

var _freeportAsync = require('freeport-async');

var _freeportAsync2 = _interopRequireDefault(_freeportAsync);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _AsyncIterableRingBuffer = require('./graphql/AsyncIterableRingBuffer');

var _AsyncIterableRingBuffer2 = _interopRequireDefault(_AsyncIterableRingBuffer);

var _GraphQLSchema = require('./graphql/GraphQLSchema');

var _GraphQLSchema2 = _interopRequireDefault(_GraphQLSchema);

var _createContext = require('./graphql/createContext');

var _createContext2 = _interopRequireDefault(_createContext);

var _Issues = require('./graphql/Issues');

var _Issues2 = _interopRequireDefault(_Issues);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const serverStartTimeUTCString = new Date().toUTCString();

function setHeaders(res) {
  // Set the Last-Modified header to server start time because otherwise it
  // becomes Sat, 26 Oct 1985 08:15:00 GMT for files installed from npm.
  res.setHeader('Last-Modified', serverStartTimeUTCString);
}

function startGraphQLServer(projectDir, httpServer) {
  const layout = createLayout();
  const issues = new _Issues2.default();
  const messageBuffer = createMessageBuffer(projectDir, issues);

  _subscriptionsTransportWs.SubscriptionServer.create({
    schema: _GraphQLSchema2.default,
    execute: graphql.execute,
    subscribe: graphql.subscribe,
    onOperation: (operation, params) => (0, _extends3.default)({}, params, {
      context: (0, _createContext2.default)({
        projectDir,
        messageBuffer,
        layout,
        issues
      })
    })
  }, { server: httpServer, path: '/graphql' });
}

function createLayout() {
  let layout = {
    selected: null,
    sources: null,
    sourceLastReads: {}
  };
  return {
    get() {
      return layout;
    },
    set(newLayout) {
      layout = (0, _extends3.default)({}, layout, newLayout);
    },
    setLastRead(sourceId, lastReadCursor) {
      layout.sourceLastReads[sourceId] = lastReadCursor;
    }
  };
}

function createMessageBuffer(projectRoot, issues) {
  const buffer = new _AsyncIterableRingBuffer2.default(10000);

  // eslint-disable-next-line no-new
  new _xdl.PackagerLogsStream({
    projectRoot,
    updateLogs: updater => {
      const chunks = updater([]);
      chunks.forEach(chunk => {
        if (chunk.issueId) {
          if (chunk.issueCleared) {
            issues.clearIssue(chunk.issueId);
          } else {
            issues.addIssue(chunk.issueId, chunk);
          }
          return;
        }
        buffer.push({
          type: 'ADDED',
          sourceId: _createContext.PROCESS_SOURCE.id,
          node: chunk
        });
      });
    },
    onStartBuildBundle: chunk => {
      buffer.push({
        type: 'ADDED',
        sourceId: _createContext.PROCESS_SOURCE.id,
        node: (0, _extends3.default)({}, chunk, {
          progress: 0,
          duration: 0
        })
      });
    },
    onProgressBuildBundle: (percentage, start, chunk) => {
      buffer.push({
        type: 'UPDATED',
        sourceId: _createContext.PROCESS_SOURCE.id,
        node: (0, _extends3.default)({}, chunk, {
          progress: percentage,
          duration: new Date() - (start || new Date())
        })
      });
    },
    onFinishBuildBundle: (error, start, end, chunk) => {
      buffer.push({
        type: 'UPDATED',
        sourceId: _createContext.PROCESS_SOURCE.id,
        node: (0, _extends3.default)({}, chunk, {
          error,
          duration: end - (start || new Date())
        })
      });
    }
  });

  // needed for validation logging to function
  _xdl.ProjectUtils.attachLoggerStream(projectRoot, {
    stream: {
      write: chunk => {
        if (chunk.tag === 'device') {
          buffer.push({
            type: 'ADDED',
            sourceId: chunk.deviceId,
            node: chunk
          });
        }
      }
    },
    type: 'raw'
  });

  _xdl.Logger.global.addStream({
    stream: {
      write: chunk => {
        buffer.push({
          type: 'ADDED',
          sourceId: _createContext.PROCESS_SOURCE.id,
          node: chunk
        });
      }
    },
    type: 'raw'
  });

  return buffer;
}